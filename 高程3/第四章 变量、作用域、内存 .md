# 4.1 基本类型和引用类型

基本类型： 简单的数据段

引用类型：多个值构成的对象

在将一个值赋给一个变量之前，首先要判断这个是是基本类型还是引用类型。引用类型的值是保存在内存中的对象，js不能直接访问内存的位置，要通过引用来操作，所以操作的是引用 不是实际的值。

* 动态的属性

  对于引用类型的值，我们可以添加属性和方法。也可以改变和删除属性和方法

* 复制变量值

  基本类型复制值。是保存它的副本、但是他们是完全独立的。值保存在栈内存中。

  引用类型：两个变量实际上是指向同一个对象、改变其中一个变量 就会影响到另一个变量。保存在堆内存中。

* **传递参数**

  ECMAScript中**所有的函数参数都是按值传递**的。基本类型值得传递如同基本类型变量的复制一样，而引用类型值得传递，如同引用类型变量的复制一样。

  基本类型：**被传递的值会被复制给一个局部变量**（即命名参数，或者用ECMAScript来说就是arguments对象中的一个元素）在向参数传递引用类型的值，会把这个值在内存中的地址复制给一个局部变量、因此这个局部变量的变化会反应在函数的外部。

  ```javascript
  function setName(obj) {
    obj.name = 'shiyao';
  }
  var person = new Object();
  setName(person);
  console.log(person); // 'shiyao ' 
  ```

  这里内部的改变会反映到外部的person。局部变量的修改会反映在全局变量中，但是不能说明参数是按照引用传递的。看下面这个例子

  ```javascript
  function setName2(obj) {
    obj.name = 'shiyao';
    obj = new Object(); // 重写obj局部变量、
    obj.name = 'syo'; // 但是在函数执行完毕之后会销毁局部变量对象
  }
  var person = new Object();
  setName2(person);
  console.log(person.name); // shiyao
  ```

  这里新创建一个对象并且赋给obj，同时修改name属性值。但是最后person的name属性值还没有变，表示原始的引用仍然保持不变。**实际上、在函数内部重写obj时，这个变量引用就是一个局部变量，而局部变量在函数执行完毕之后会自动销毁**。ECMAScript 函数的参数想象成局部变量

* 检测类型

  typeof操作符 是确定一个变量是 字符串、数值、布尔值、还是undefined。如果变量是一个对象或null返回object。函数会返回 function。

  instanceof 我们想知道某个值是什么类型的对象。

  obj instanceof Object; // true

## 4.2 执行环境及作用域

每一个函数都有一个自己的执行环境。当代码在一个环境中执行，会创建变量对象的一个作用域链。作用域的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。

## 4.3 垃圾收集

* 标记清除

* 引用计数

  手动的解除。通过设置其值为null来释放引用。**解除引用** 



## 小结

* 基本类型值在内存中占据固定大小的空间、保存在栈内存中；

* 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；

* 引用类型的值是对象，保存在堆内存中

* 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；

*  从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同

  一个对象；

  ​